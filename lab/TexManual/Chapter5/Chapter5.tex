\chapter{Linear Queue Operations}
\section*{Question}
{\fontfamily{ppl}\selectfont \textbf{Write a C program to implement ordinary QUEUE to perform the insertion, deletion and display operations.
}}

\section*{C Code}
\textit{LinearQueue.c
}
\begin{Verbatim}
/***************************************************************************
*File		: LinearQueue
*Description	: Program to implement a Linear Queue of intrgers
*Author		: Prabodh C P
*Compiler	: gcc compiler4.4.3, Ubuntu 10.04
*Date		: 11 July 2012
***************************************************************************/
#include<stdio.h>									/*CPP*/
#include<stdlib.h>
#include "queue.h"
#include "QFunc.c"

/***************************************************************************
*Function	: 	main
*Input parameters:	no parameters
*RETURNS	:	0 on success
***************************************************************************/
int main(void)
{
    QUEUE stQueue;
	int iChoice;
	stQueue.iFront = 0;
	stQueue.iRear = -1;
	for(;;)
	{
                printf("\nQueue Operations\n");
                printf("=====================");

		printf("\n1.Qinsert\n2.Qdelete\n3.Qdisplay\n4.Exit\n");
		printf("Enter your choice\n");
		scanf("%d",&iChoice);
		switch(iChoice)
		{
			case 1: stQueue = fnQInsert(stQueue);

				break;
			case 2: stQueue = fnQDelete(stQueue);

				break;
			case 3: fnQDisplay(stQueue);

				break;
			case 4: exit(0);
			default: printf("\nWrong Choice\n");
				break;
		}
	}
	return 0;
}
\end{Verbatim}

\textit{queue.h
}
\begin{Verbatim}
#ifndef QUEUE_H_INCLUDED
#define QUEUE_H_INCLUDED
#define SIZE 5
typedef struct
{
	int iaItems[SIZE];
	int iFront;
	int iRear;
}QUEUE;

QUEUE fnQInsert(QUEUE stQueue);
QUEUE fnQDelete(QUEUE stQueue);
void fnQDisplay(QUEUE stQueue);
int fnQFull(QUEUE stQueue);
int fnQEmpty(QUEUE stQueue);

#endif // QUEUE_H_INCLUDED
\end{Verbatim}

\textit{QFunc.c
}
\begin{Verbatim}
/***************************************************************************
*Function	: 	fnQInsert
*Description:   inserts an element at the rear of the queue
*Input parameters: a structure queue
*RETURNS	:	updated queue
***************************************************************************/

QUEUE fnQInsert(QUEUE stQueue)
{
	int iItem;
	if(fnQFull(stQueue))
	printf("\nQueue Overflow\n");
	else
	{
		printf("\nEnter the  element\n");
		scanf("%d",&iItem);
		stQueue.iRear++;
		stQueue.iaItems[stQueue.iRear] = iItem;

	}
	return stQueue;
}

/***************************************************************************
*Function	: 	fnQDelete
*Description:   deletes an element from the front of the queue
*Input parameters: a structure queue
*RETURNS	:	updated queue
***************************************************************************/

QUEUE fnQDelete(QUEUE stQueue)
{
	if(fnQEmpty(stQueue))
	printf("\nQueue Underflow\n");
	else
	if(stQueue.iRear == stQueue.iFront)
	{
		printf("\nItem deleted is %d\n",stQueue.iaItems[stQueue.iFront]);
		stQueue.iRear=-1;
		stQueue.iFront=0;
	}
	else
	{
		printf("\nItem deleted is %d\n",stQueue.iaItems[stQueue.iFront++]);
	}
	return stQueue;
}

/***************************************************************************
*Function	: 	fnQDisplay
*Description:   displays elements of the queue
*Input parameters: a structure queue
*RETURNS	:	nothing
***************************************************************************/
void fnQDisplay(QUEUE stQueue)
{
	int i;
	if(fnQEmpty(stQueue))
	printf("\nQueue Empty\n");
	else
	{
		printf("\nContents of Queue are:\n");
		for(i=stQueue.iFront;i<=stQueue.iRear;i++)
		printf("%d\t",stQueue.iaItems[i]);
	}
}
/***************************************************************************
*Function	: 	fnQFull
*Description:   checks wheteher the queue is full or not
*Input parameters: a structure queue
*RETURNS	:	1 if the queue is full or 0 otherwise
***************************************************************************/
int fnQFull(QUEUE stQueue)
{
	if(stQueue.iRear == SIZE-1)
		return 1;
	else
		return 0;
}

/***************************************************************************
*Function	: 	fnQEmpty
*Description:   checks wheteher the queue is empty or not
*Input parameters: a structure queue
*RETURNS	:	1 if the queue is empty or 0 otherwise
***************************************************************************/
int fnQEmpty(QUEUE stQueue)
{
	if(stQueue.iRear == stQueue.iFront-1)
		return 1;
	else
		return 0;
}
\end{Verbatim}


\section*{Output}
\begin{Verbatim}



\end{Verbatim}

